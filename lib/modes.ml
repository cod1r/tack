open Ui_textarea
open Sdl

module type Mode = sig
  val handle_mode_evt : Editor.editor -> Sdl.event option -> Editor.editor
end

(* let handle_mode_evt (editor : Editor.editor) (evt : Sdl.event option) = *)
(*   let Editor. *)
(*         { *)
(*           rope; *)
(*           file_name; *)
(*           cursor_pos; *)
(*           vertical_scroll_y_offset; *)
(*           last_modification_time; *)
(*           highlight; *)
(*         } = *)
(*     List.nth editor.ropes (editor.current_rope_idx |> Option.get) *)
(*   in *)
(*   let other_rope_wrappers = *)
(*     List.filteri *)
(*       (fun idx _ -> idx != (editor.current_rope_idx |> Option.get)) *)
(*       editor.ropes *)
(*   in *)
(*   match evt with *)
(*   | Some (KeyboardEvt { keysym; kbd_evt_type; _ }) -> *)
(*       Printf.printf "KBD file mode: %d, %s" (Char.code keysym) *)
(*         (Char.escaped keysym); *)
(*       print_newline (); *)
(*       let char_code = Char.code keysym in *)
(*       handle_kbd_evt_editor_mode editor ~char_code ~kbd_evt_type ~keysym *)
(*         ~file_path:file_name *)
(*   | Some (MouseButtonEvt { mouse_evt_type; x; y; _ }) -> ( *)
(*       match mouse_evt_type with *)
(*       | Mousedown -> *)
(*           Printf.printf "Mousedown %d, %d\n" x y; *)
(*           let crp = *)
(*             if Option.is_some rope then *)
(*               let rope = Option.get rope in *)
(*               let num_lines = Editor.num_lines rope in *)
(*               let digits_widths_summed = *)
(*                 Editor.get_digits_widths_summed ~num_lines ~editor *)
(*               in *)
(*               Editor.find_closest_rope_pos_for_cursor_on_coords ~editor ~x ~y *)
(*                 ~digits_widths_summed *)
(*             else 0 *)
(*           in *)
(*           Printf.printf "ROPE POS: %d" crp; *)
(*           print_newline (); *)
(*           let new_rope_wrapper = *)
(*             Editor. *)
(*               { *)
(*                 file_name; *)
(*                 cursor_pos = crp; *)
(*                 rope; *)
(*                 vertical_scroll_y_offset; *)
(*                 last_modification_time; *)
(*                 highlight; *)
(*               } *)
(*           in *)
(*           let new_editor = *)
(*             { editor with ropes = new_rope_wrapper :: other_rope_wrappers } *)
(*           in *)
(*           new_editor *)
(*       | Mouseup -> *)
(*           Printf.printf "Mouseup: %d %d" x y; *)
(*           print_newline (); *)
(*           let new_rope_wrapper = *)
(*             Editor. *)
(*               { *)
(*                 file_name; *)
(*                 cursor_pos; *)
(*                 rope; *)
(*                 vertical_scroll_y_offset; *)
(*                 last_modification_time; *)
(*                 highlight = None; *)
(*                 (* (if crp != cursor_pos then *)
  (*                          Some (min crp cursor_pos, max crp cursor_pos) *)
  (*                        else None); *) *)
(*               } *)
(*           in *)
(*           let new_editor = *)
(*             { editor with ropes = new_rope_wrapper :: other_rope_wrappers } *)
(*           in *)
(*           new_editor) *)
(*   | Some (WindowEvt { event; _ }) -> ( *)
(*       match event with *)
(*       | WindowClose -> editor *)
(*       | WindowResize -> *)
(*           let window_width, window_height = Sdl.sdl_gl_getdrawablesize () in *)
(*           Opengl.gl_set_viewport 0 0 window_width window_height; *)
(*           editor *)
(*       | Unhandled -> editor) *)
(*   | Some (MouseMotionEvt _) -> *)
(*       (* Printf.printf "Mousemotion %d %d" x y; *)
  (*           print_newline (); *) *)
(*       editor *)
(*   | Some (MouseWheelEvt { y; _ }) -> *)
(*       let num_lines' = *)
(*         if Option.is_some rope then Editor.num_lines (Option.get rope) else 0 *)
(*       in *)
(*       let limit = 0 in *)
(*       let new_rope_wrapper = *)
(*         Editor. *)
(*           { *)
(*             rope; *)
(*             cursor_pos; *)
(*             file_name; *)
(*             vertical_scroll_y_offset = *)
(*               min limit (max (-num_lines' + 1) (vertical_scroll_y_offset + y)); *)
(*             last_modification_time; *)
(*             highlight; *)
(*           } *)
(*       in *)
(*       let new_editor = *)
(*         { *)
(*           editor with *)
(*           ropes = new_rope_wrapper :: other_rope_wrappers; *)
(*           current_rope_idx = Some 0; *)
(*         } *)
(*       in *)
(*       new_editor *)
(*   | Some (TextInputEvt { text; _ }) -> *)
(*       let new_rope = *)
(*         match rope with *)
(*         | Some r -> Some (Rope.insert r cursor_pos text) *)
(*         | None -> Some (Leaf text) *)
(*       in *)
(*       let new_rope_wrapper = *)
(*         Editor. *)
(*           { *)
(*             file_name; *)
(*             cursor_pos = cursor_pos + 1; *)
(*             rope = new_rope; *)
(*             vertical_scroll_y_offset; *)
(*             last_modification_time; *)
(*             highlight; *)
(*           } *)
(*       in *)
(*       let new_editor : Editor.editor = *)
(*         { *)
(*           editor with *)
(*           ropes = new_rope_wrapper :: other_rope_wrappers; *)
(*           current_rope_idx = Some 0; *)
(*         } *)
(*       in *)
(*       new_editor *)
(*   | _ -> editor *)
