open Ui_textarea
open Sdl

module type Mode = sig
  val handle_mode_evt : Editor.editor -> Sdl.event option -> Editor.editor
end
(* function i made in the process of thinking of a good answer to different editor modes (file search mode, editing mode, etc; this probably isn't needed *)
(* let handle_kbd_evt_editor_mode ~(font_info: Ui.font_info) ~char_code *)
(*     ~kbd_evt_type ~keysym ~file_path = *)
(*   let Editor. *)
(*         { *)
(*           rope; *)
(*           cursor_pos; *)
(*           file_name; *)
(*           last_modification_time; *)
(*           highlight; *)
(*           scroll_y_offset *)
(*         } = *)
(*     List.nth editor.ropes (editor.current_rope_idx |> Option.get) *)
(*   in *)
(*   let other_rope_wrappers = *)
(*     List.filteri *)
(*       (fun idx _ -> idx != (editor.current_rope_idx |> Option.get)) *)
(*       editor.ropes *)
(*   in *)
(*   match rope with *)
(*   | Some r -> ( *)
(*       match char_code with *)
(*       | 1073742048 -> ( *)
(*           (* this is the integer encoding for ctrl in SDL *) *)
(*           match kbd_evt_type with *)
(*           | Sdl.Keydown -> { editor with holding_ctrl = true } *)
(*           | Keyup -> { editor with holding_ctrl = false }) *)
(*       | 1073741904 (* left arrow key *) when kbd_evt_type = Keydown -> *)
(*           let new_rope_wrapper = *)
(*             Editor. *)
(*               { *)
(*                 rope; *)
(*                 cursor_pos = max 0 (cursor_pos - 1); *)
(*                 file_name; *)
(*                 last_modification_time; *)
(*                 highlight; *)
(*                 scroll_y_offset *)
(*               } *)
(*           in *)
(*           let new_editor = *)
(*             { editor with ropes = new_rope_wrapper :: other_rope_wrappers } *)
(*           in *)
(*           new_editor *)
(*       | 1073741906 (* up arrow key *) when kbd_evt_type = Keydown -> *)
(*           let Ui_textarea.{ x; y; _ } = *)
(*             Ui_textarea.find_coords_for_cursor_pos ~editor *)
(*           in *)
(*           let cursor_pos' = *)
(*             Editor.find_closest_rope_pos_for_moving_cursor_in_vertical_range *)
(*               ~editor ~cursor_x:x *)
(*               ~lower_y:(y - editor.config_info.font_height) *)
(*           in *)
(*           let new_rope_wrapper = *)
(*             Editor. *)
(*               { *)
(*                 rope; *)
(*                 cursor_pos = max 0 cursor_pos'; *)
(*                 file_name; *)
(*                 vertical_scroll_y_offset = *)
(*                   (if y = editor.bounds.y then *)
(*                      min 0 (vertical_scroll_y_offset + 1) *)
(*                    else vertical_scroll_y_offset); *)
(*                 last_modification_time; *)
(*                 highlight; *)
(*               } *)
(*           in *)
(*           let new_editor = *)
(*             { editor with ropes = new_rope_wrapper :: other_rope_wrappers } *)
(*           in *)
(*           new_editor *)
(*       | 1073741903 (* right arrow key *) when kbd_evt_type = Keydown -> *)
(*           let new_rope_wrapper = *)
(*             Editor. *)
(*               { *)
(*                 rope; *)
(*                 cursor_pos = *)
(*                   min *)
(*                     (if Option.is_some rope then *)
(*                        Option.get rope |> Rope.length *)
(*                      else 0) *)
(*                     (cursor_pos + 1); *)
(*                 file_name; *)
(*                 vertical_scroll_y_offset; *)
(*                 last_modification_time; *)
(*                 highlight; *)
(*               } *)
(*           in *)
(*           let new_editor = *)
(*             { editor with ropes = new_rope_wrapper :: other_rope_wrappers } *)
(*           in *)
(*           new_editor *)
(*       | 1073741905 (* down arrow key *) when kbd_evt_type = Keydown -> *)
(*           if Option.is_some rope then *)
(*             let num_lines' = Editor.num_lines (Option.get rope) in *)
(*             let Editor.{ x; y; _ } = *)
(*               Editor.find_coords_for_cursor_pos ~editor *)
(*             in *)
(*             let cursor_pos = *)
(*               Editor.find_closest_rope_pos_for_moving_cursor_in_vertical_range *)
(*                 ~editor ~cursor_x:x *)
(*                 ~lower_y:(y + editor.config_info.font_height) *)
(*             in *)
(*             let new_rope_wrapper = *)
(*               Editor. *)
(*                 { *)
(*                   rope; *)
(*                   cursor_pos; *)
(*                   file_name; *)
(*                   vertical_scroll_y_offset = *)
(*                     (if *)
(*                        y + editor.config_info.font_height *)
(*                        = editor.bounds.y + editor.bounds.height *)
(*                      then max (-num_lines' + 1) (vertical_scroll_y_offset - 1) *)
(*                      else vertical_scroll_y_offset); *)
(*                   last_modification_time; *)
(*                   highlight; *)
(*                 } *)
(*             in *)
(*             let new_editor = *)
(*               { editor with ropes = new_rope_wrapper :: other_rope_wrappers } *)
(*             in *)
(*             new_editor *)
(*           else editor *)
(*       | _ -> ( *)
(*           match keysym with *)
(*           | '\b' when kbd_evt_type = Keydown -> *)
(*               (* backspace *) *)
(*               let rope_len = Rope.length r in *)
(*               if rope_len > 0 && cursor_pos > 0 then *)
(*                 let new_rope = *)
(*                   Some *)
(*                     (match highlight with *)
(*                     | Some (start, end') -> *)
(*                         Rope.delete r ~start ~len:(end' - start) *)
(*                     | None -> Rope.delete r ~start:(cursor_pos - 1) ~len:1) *)
(*                 in *)
(*                 let new_rope_wrapper = *)
(*                   Editor. *)
(*                     { *)
(*                       file_name; *)
(*                       cursor_pos = cursor_pos - 1; *)
(*                       rope = new_rope; *)
(*                       scroll_y_offset; *)
(*                       last_modification_time; *)
(*                       highlight = None; *)
(*                     } *)
(*                 in *)
(*                 let new_editor : Editor.editor = *)
(*                   { *)
(*                     editor with *)
(*                     ropes = new_rope_wrapper :: other_rope_wrappers; *)
(*                     current_rope_idx = Some 0; *)
(*                   } *)
(*                 in *)
(*                 new_editor *)
(*               else editor *)
(*           | 'c' when kbd_evt_type = Keydown -> *)
(*               (match (rope, highlight) with *)
(*               | Some r, Some (start, end') -> *)
(*                   Rope.substring r ~start ~len:(end' - start) *)
(*                   |> Rope.to_string |> Sdl.set_clipboard_text *)
(*               | _ -> ()); *)
(*               editor *)
(*           | 'v' when kbd_evt_type = Keydown -> ( *)
(*               match editor.holding_ctrl with *)
(*               | true -> *)
(*                   let clipboard_contents = Sdl.get_clipboard_text () in *)
(*                   let new_rope = *)
(*                     match rope with *)
(*                     | Some r -> *)
(*                         Some (Rope.insert r cursor_pos clipboard_contents) *)
(*                     | None -> Some (Leaf clipboard_contents) *)
(*                   in *)
(*                   let new_rope_wrapper = *)
(*                     Editor. *)
(*                       { *)
(*                         file_name; *)
(*                         cursor_pos = *)
(*                           cursor_pos + String.length clipboard_contents; *)
(*                         rope = new_rope; *)
(*                         vertical_scroll_y_offset; *)
(*                         last_modification_time; *)
(*                         highlight; *)
(*                       } *)
(*                   in *)
(*                   let new_editor = *)
(*                     { *)
(*                       editor with *)
(*                       ropes = new_rope_wrapper :: other_rope_wrappers; *)
(*                       current_rope_idx = Some 0; *)
(*                     } *)
(*                   in *)
(*                   new_editor *)
(*               | false -> editor) *)
(*           | 's' when kbd_evt_type = Keydown -> *)
(*               (match editor.holding_ctrl with *)
(*               | true -> ( *)
(*                   match rope with *)
(*                   | Some r -> *)
(*                       Out_channel.with_open_bin file_path (fun oc -> *)
(*                           Out_channel.output_string oc (Rope.to_string r)) *)
(*                   | None -> ()) *)
(*               | false -> ()); *)
(*               editor *)
(*           | ('\r' | '\n') when kbd_evt_type = Keydown -> *)
(*               (* on macos, the return key gives \r instead of \n *) *)
(*               let new_rope = Some (Rope.insert r cursor_pos "\n") in *)
(*               let new_rope_wrapper = *)
(*                 Editor. *)
(*                   { *)
(*                     last_modification_time; *)
(*                     file_name; *)
(*                     cursor_pos = cursor_pos + 1; *)
(*                     rope = new_rope; *)
(*                     vertical_scroll_y_offset; *)
(*                     highlight; *)
(*                   } *)
(*               in *)
(*               let new_editor : Editor.editor = *)
(*                 { *)
(*                   editor with *)
(*                   ropes = new_rope_wrapper :: other_rope_wrappers; *)
(*                   current_rope_idx = Some 0; *)
(*                 } *)
(*               in *)
(*               new_editor *)
(*           | '\t' when kbd_evt_type = Keydown -> *)
(*               (* horizontal tab will be two spaces *) *)
(*               let new_rope = Some (Rope.insert r cursor_pos "  ") in *)
(*               let new_rope_wrapper = *)
(*                 Editor. *)
(*                   { *)
(*                     file_name; *)
(*                     cursor_pos = cursor_pos + 2; *)
(*                     rope = new_rope; *)
(*                     vertical_scroll_y_offset; *)
(*                     last_modification_time; *)
(*                     highlight; *)
(*                   } *)
(*               in *)
(*               let new_editor : Editor.editor = *)
(*                 { *)
(*                   editor with *)
(*                   ropes = new_rope_wrapper :: other_rope_wrappers; *)
(*                   current_rope_idx = Some 0; *)
(*                 } *)
(*               in *)
(*               new_editor *)
(*           | _ -> editor)) *)
(*   | None -> editor *)

(* let handle_mode_evt (editor : Editor.editor) (evt : Sdl.event option) = *)
(*   let Editor. *)
(*         { *)
(*           rope; *)
(*           file_name; *)
(*           cursor_pos; *)
(*           vertical_scroll_y_offset; *)
(*           last_modification_time; *)
(*           highlight; *)
(*         } = *)
(*     List.nth editor.ropes (editor.current_rope_idx |> Option.get) *)
(*   in *)
(*   let other_rope_wrappers = *)
(*     List.filteri *)
(*       (fun idx _ -> idx != (editor.current_rope_idx |> Option.get)) *)
(*       editor.ropes *)
(*   in *)
(*   match evt with *)
(*   | Some (KeyboardEvt { keysym; kbd_evt_type; _ }) -> *)
(*       Printf.printf "KBD file mode: %d, %s" (Char.code keysym) *)
(*         (Char.escaped keysym); *)
(*       print_newline (); *)
(*       let char_code = Char.code keysym in *)
(*       handle_kbd_evt_editor_mode editor ~char_code ~kbd_evt_type ~keysym *)
(*         ~file_path:file_name *)
(*   | Some (MouseButtonEvt { mouse_evt_type; x; y; _ }) -> ( *)
(*       match mouse_evt_type with *)
(*       | Mousedown -> *)
(*           Printf.printf "Mousedown %d, %d\n" x y; *)
(*           let crp = *)
(*             if Option.is_some rope then *)
(*               let rope = Option.get rope in *)
(*               let num_lines = Editor.num_lines rope in *)
(*               let digits_widths_summed = *)
(*                 Editor.get_digits_widths_summed ~num_lines ~editor *)
(*               in *)
(*               Editor.find_closest_rope_pos_for_cursor_on_coords ~editor ~x ~y *)
(*                 ~digits_widths_summed *)
(*             else 0 *)
(*           in *)
(*           Printf.printf "ROPE POS: %d" crp; *)
(*           print_newline (); *)
(*           let new_rope_wrapper = *)
(*             Editor. *)
(*               { *)
(*                 file_name; *)
(*                 cursor_pos = crp; *)
(*                 rope; *)
(*                 vertical_scroll_y_offset; *)
(*                 last_modification_time; *)
(*                 highlight; *)
(*               } *)
(*           in *)
(*           let new_editor = *)
(*             { editor with ropes = new_rope_wrapper :: other_rope_wrappers } *)
(*           in *)
(*           new_editor *)
(*       | Mouseup -> *)
(*           Printf.printf "Mouseup: %d %d" x y; *)
(*           print_newline (); *)
(*           let new_rope_wrapper = *)
(*             Editor. *)
(*               { *)
(*                 file_name; *)
(*                 cursor_pos; *)
(*                 rope; *)
(*                 vertical_scroll_y_offset; *)
(*                 last_modification_time; *)
(*                 highlight = None; *)
(*                 (* (if crp != cursor_pos then *)
  (*                          Some (min crp cursor_pos, max crp cursor_pos) *)
  (*                        else None); *) *)
(*               } *)
(*           in *)
(*           let new_editor = *)
(*             { editor with ropes = new_rope_wrapper :: other_rope_wrappers } *)
(*           in *)
(*           new_editor) *)
(*   | Some (WindowEvt { event; _ }) -> ( *)
(*       match event with *)
(*       | WindowClose -> editor *)
(*       | WindowResize -> *)
(*           let window_width, window_height = Sdl.sdl_gl_getdrawablesize () in *)
(*           Opengl.gl_set_viewport 0 0 window_width window_height; *)
(*           editor *)
(*       | Unhandled -> editor) *)
(*   | Some (MouseMotionEvt _) -> *)
(*       (* Printf.printf "Mousemotion %d %d" x y; *)
  (*           print_newline (); *) *)
(*       editor *)
(*   | Some (MouseWheelEvt { y; _ }) -> *)
(*       let num_lines' = *)
(*         if Option.is_some rope then Editor.num_lines (Option.get rope) else 0 *)
(*       in *)
(*       let limit = 0 in *)
(*       let new_rope_wrapper = *)
(*         Editor. *)
(*           { *)
(*             rope; *)
(*             cursor_pos; *)
(*             file_name; *)
(*             vertical_scroll_y_offset = *)
(*               min limit (max (-num_lines' + 1) (vertical_scroll_y_offset + y)); *)
(*             last_modification_time; *)
(*             highlight; *)
(*           } *)
(*       in *)
(*       let new_editor = *)
(*         { *)
(*           editor with *)
(*           ropes = new_rope_wrapper :: other_rope_wrappers; *)
(*           current_rope_idx = Some 0; *)
(*         } *)
(*       in *)
(*       new_editor *)
(*   | Some (TextInputEvt { text; _ }) -> *)
(*       let new_rope = *)
(*         match rope with *)
(*         | Some r -> Some (Rope.insert r cursor_pos text) *)
(*         | None -> Some (Leaf text) *)
(*       in *)
(*       let new_rope_wrapper = *)
(*         Editor. *)
(*           { *)
(*             file_name; *)
(*             cursor_pos = cursor_pos + 1; *)
(*             rope = new_rope; *)
(*             vertical_scroll_y_offset; *)
(*             last_modification_time; *)
(*             highlight; *)
(*           } *)
(*       in *)
(*       let new_editor : Editor.editor = *)
(*         { *)
(*           editor with *)
(*           ropes = new_rope_wrapper :: other_rope_wrappers; *)
(*           current_rope_idx = Some 0; *)
(*         } *)
(*       in *)
(*       new_editor *)
(*   | _ -> editor *)
