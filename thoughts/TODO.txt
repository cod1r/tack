Priorities:
    currently there's an issue where the child box will try and max its size to the parents size and the parent will try and min its size to the child's size so neither gets the right size...
        perhaps the answer to this is to introduce a min size and a max size if the box
        cannot be clamped to it's parent or child size
    build out scuffed editor
    borders
    clamping content to width/height of window
    really think about if relying on reference equality is good or not
    also making every record type in ui, mutable is really messing with me. gotta rethink how im doing this entire thing
        gotta also think about whether it's really bad to have all of this mutability...
        i dont think it's necessarily that bad... i think it could work
    implement padding
    parse ripgrep json output format for searching text
    implement undo and redo functionality


look into freetype and harfbuzz
think about statically linking things vs dynamically linking things

gotta handle modifier key + key somehow...either through sdl_textinputevent or i just have to manually implement the logic for it
 - I'm using sdl_textinputevent to handle keys resulting from modifiers and then using sdl_keydown events to handle backspaces etc
think about text cursors

gotta rewrite some of the stub code that errors with caml_failwith to use result types so that it's clear in the ocaml code that
an error can occur and the error needs to be handled. using functions that only do side effects and dont tell the caller anything is
messy.

maybe use doxygen and ocamldoc for documentation generation.

vim motions?

basic features:
  basic text manipulation like highlighting, deleting, copy/paste
  multi cursors
  LSP
  text search

current questions:
  how to set proper point size if DPI isnt easily accessible?
current problems:
  memory usage is too high
  performance is not ideal (still need to test on large amounts of text)

Using Int_val instead of Long_val might fuck me over in the future. idk...

there needs to be a faster and better way to go from screen coords to a position in the rope data structure.

CLEAN UP CODE!!

displaying line numbers

Things to note and remember:
  text is positioned by taking it's relative horizontal position in the rope and wrapping the value around the window width.

blinking cursor?

arrow keys should properly move text caret

UNDO TREE SHIT

SOME WAY TO SWITCH FILES QUICKLY

MOUSEDOWN handling needs to be more accurate

rope data structure needs to be built in a way such that there is less depth for SPEED (basically balance between leaf length and tree depth)

more things to do:
  - There is too much nested state, so things are hard to read. this means another session of code cleanup
  - every file should keep track of its scroll position
  - every file needs to occasionally poll if it's contents have changed on disk and make a decision about current changes vs
    changes on disk
  - build some sort of a layout "engine"
  - make some ui elements that can handle text behaviors

findings about behavior on linux vs macos:
  - on linux, resize events are sent every time a slight change in size happens whereas on macos, the resize event is sent after the resizing is done
  - on linux, the opengl viewport is not resized to match the window size/resize but on macos, it is

Current design thoughts:
- The "editor" is a ui component that has line numbers and an area to display text.
It will be used to display anything that can be displayed with text; eg - file searching, etc
- Maybe things should be built like a window manager but for text editing?
- Binary Space Partition?
